 from astropy.io import fitsimport numpy as npimport sysimport osimport globfrom numpy import pi, r_import matplotlib.pyplot as pltfrom scipy import optimizeimport mathfrom astropy.modeling.models import custom_modelfrom astropy.modeling.fitting import LevMarLSQFitterimport socketimport scipy.linalgfrom mpl_toolkits.mplot3d import Axes3Dimport picklefrom matplotlib.backends.backend_pdf import PdfPagesfrom astropy.stats import sigma_clipped_statsfrom photutils.detection import DAOStarFinderimport copyfrom matplotlib.colors import LogNormdef boxCentres(cameraID):    ''' This isn't really a function, more jsut a place to store key lookup values. For each camera there '''        if cameraID == 'RI1':       xboxCentres = np.array([821, 842, 843, 826, 792, 1613, 1629, 1627, 1611, 1586, 2489, 2498, 2496, 2479, 2457, 2795, 2803, 2800, 2783, 2764, 3529, 3528, 3523, 3511, 3493])       yboxCentres = np.array([4076, 3142, 2222, 1187, 381, 4062, 3137, 2217, 1186, 383, 4062, 3134, 2215, 1182, 381, 4058, 3133, 2211, 1181, 376, 4064, 3132, 2211, 1171, 366])           if cameraID == 'RI2':# old       xboxCentres = np.array([673, 666, 657, 664, 666, 1406, 1391, 1383, 1391, 1401, 2218, 2199, 2060, 2197, 2212, 2885, 2862, 2850, 2859, 2881, 3378, 3353, 3340, 3350, 3375])# old      yboxCentres = np.array([3939, 3130, 2221, 1186, 259, 3930, 3126, 2221, 1189, 273, 3926, 3126, 2222, 1190, 275, 3928, 3127, 2222, 1190, 274, 3934, 3128, 2223, 1190, 270])       # slit at 0 position       xboxCentres =  np.array([675, 666, 659, 662, 668, 1408, 1393, 1382, 1389, 1400, 1891, 1873, 1863, 1872, 1885, 2586, 2566, 2556, 2564, 2585, 2883, 2861, 2850, 2859, 2881])       yboxCentres =  np.array([3937, 3128, 2219, 1183, 261, 3929, 3126, 2223, 1190, 274, 3924, 3122, 2222, 1189, 275, 3925, 3122, 2221, 1188, 275, 3929, 3127, 2223, 1190, 277])       # slit offset to -95 position       xboxCentres =  np.array([542, 536, 528, 534, 534, 1519, 1504, 1494, 1500, 1513, 2482, 2463, 2450, 2461, 2479, 2588, 2566, 2554, 2565, 2582, 3381, 3355, 3341, 3353, 3377])       yboxCentres =  np.array([3959, 3138, 2220, 1175, 243, 3944, 3133, 2221, 1180, 257, 3942, 3133, 2222, 1181, 260, 3942, 3132, 2221, 1182, 258, 3949, 3135, 2220, 1178, 252])                  if cameraID == 'HRI2':       xboxCentres =  np.array([1004, 972, 957, 970, 1004, 1427, 1393, 1378, 1391, 1427, 2286, 2251, 2231, 2249, 2290, 2994, 2953, 2932, 2953, 2998, 3824, 3774, 3751, 3773, 3830])       yboxCentres =  np.array([3911, 3108, 2202, 1169, 250, 3908, 3105, 2202, 1170, 253, 3908, 3106, 2203, 1171, 259, 3911, 3106, 2202, 1169, 254, 3923, 3113, 2202, 1165, 243])    if cameraID == 'YJ1':       # previous centres used in analysis before checking for doubles       #xboxCentres =  np.array([607, 636, 642, 631, 604, 1210, 1233, 1237, 1227, 1205, 2105, 2122, 2124, 2115, 2099, 2951, 2961, 2962, 2956, 2944, 3931, 3930, 3927, 3924, 3921])       #yboxCentres =  np.array([190, 1127, 2047, 2976, 3781, 197, 1128, 2046, 2971, 3774, 201, 1130, 2045, 2970, 3772, 196, 1128, 2045, 2972, 3775, 176, 1114, 2044, 2980, 3794])       # new centres used in analysis after checking for doubles       #xboxCentres =  np.array([607, 636, 642, 631, 604, 1391, 1413, 1416, 1406, 1386, 2105, 2122, 2124, 2115, 2099, 2951, 2961, 2962, 2956, 2944, 3717, 3719, 3716, 3713, 3706])       #yboxCentres =  np.array([190, 1127, 2047, 2976, 3781, 197, 1128, 2046, 2971, 3774, 201, 1130, 2045, 2970, 3772, 196, 1128, 2045, 2972, 3775, 178, 1122, 2044, 2976, 3786])    # For 0 slit focus position       xboxCentres =  np.array([604, 633, 638, 626, 599, 1387, 1407, 1411, 1401, 1380, 2104, 2120, 2122, 2113, 2096, 2951, 2961, 2961, 2956, 2943, 3713, 3717, 3714, 3710, 3704])       yboxCentres =  np.array([178, 1117, 2047, 2960, 3777, 187, 1120, 2045, 2958, 3769, 188, 1121, 2045, 2957, 3768, 183, 1119, 2045, 2958, 3773, 170, 1114, 2045, 2963, 3784])    # For +1.4 slit focus position    # Positive is moving the slit down towards the collimator.    # Image gets smaller    # 3mm of slit movement getting closer, moves upper fibre by .14mm from centre and same amount from bottom 0.14mm    # Beam seems to get shorter from top to     #   xboxCentres =  np.array([604, 633, 638, 626, 599, 1387, 1407, 1411, 1401, 1380, 2104, 2120, 2122, 2113, 2096, 2951, 2961, 2961, 2956, 2943, 3708, 3712, 3709, 3705, 3700])    #   yboxCentres =  np.array([188, 1122, 2047, 2950, 3762, 197, 1125, 2045, 2948, 3754, 198, 1126, 2045, 2947, 3753, 193, 1124, 2045, 2948, 3758, 180, 1119, 2045, 2953, 3769])    # For -1.4 slit focus position    # Image gets larger    # Beam seems to get shorter from top to        xboxCentres =  np.array([599, 628, 633, 621, 594, 1387, 1407, 1411, 1401, 1380, 2104, 2120, 2122, 2113, 2096, 2951, 2961, 2961, 2956, 2943, 3717, 3721, 3718, 3714, 3708])       yboxCentres =  np.array([168, 1112, 2047, 2965, 3787, 177, 1115, 2045, 2963, 3779, 178, 1116, 2045, 2963, 3778, 173, 1114, 2045, 2963, 3783, 160, 1109, 2045, 2968, 3794])    if cameraID == 'H1':       xboxCentres =  np.array([378, 406, 417, 409, 388,        862, 883, 892, 889, 873,       1792, 1804, 1810, 1809, 1799,    2952, 2955, 2960, 2960, 2961,    3663, 3657, 3659, 3663, 3669])       yboxCentres =  np.array([197, 1137, 2067, 2983, 3795,    210, 1145, 2068, 2980, 3788,   221, 1149, 2070, 2979, 3785,     221, 1151, 2073, 2983, 3790,     208, 1147, 2075, 2988, 3803])# slit offset position -50    #   xboxCentres =  np.array([379, 402, 408, 397, 370, 1382, 1395, 1397, 1389, 1372, 2321, 2325, 2328, 2325, 2314, 3236, 3235, 3235, 3228, 3228, 3675, 3668, 3665, 3662, 3668])    #   yboxCentres =  np.array([3809, 2984, 2062, 1128, 183, 3795, 2979, 2065, 1137, 201, 3797, 2980, 2069, 1142, 205, 3803, 2986, 2068, 1143, 196, 3813, 2991, 2069, 1142, 193])# slit offset position +25.76    #   xboxCentres =  np.array([387, 408, 414, 403, 376, 1385, 1397, 1400, 1390, 1374, 2324, 2327, 2326, 2322, 2312, 3237, 3232, 3231, 3227, 3226, 3670, 3661, 3661, 3657, 3665])     #  yboxCentres =  np.array([3795, 2978, 2062, 1137, 198, 3783, 2973, 2064, 1144, 214, 3784, 2976, 2068, 1148, 223, 3791, 2981, 2070, 1149, 217, 3802, 2985, 2071, 1149, 209])# slit at +25.76 position and using 5 fibres at the top and bottom. Anlaysis just took top 3 and bottom two fibre.    #   xboxCentres =  np.array([379, 383, 384, 395, 390, 867, 875, 873, 880, 875, 2314, 2319, 2317, 2325, 2322, 3228, 3231, 3225, 3234, 3234, 3665, 3664, 3660, 3669, 3670])    #   yboxCentres =  np.array([202, 324, 442, 3679, 3796, 214, 335, 451, 3672, 3790, 226, 345, 463, 3669, 3783, 219, 340, 455, 3676, 3792, 213, 332, 451, 3683, 3802])    if cameraID == 'H2':       xboxCentres =  [647, 653, 659, 657, 661, 1064, 1065, 1070, 1071, 1079, 1851, 1848, 1850, 1854, 1869, 2786, 2774, 2777, 2782, 2806, 3779, 3761, 3759, 3770, 3803]       yboxCentres =  [3685, 2880, 1972, 1064, 140, 3680, 2875, 1973, 1066, 149, 3676, 2874, 1975, 1072, 155, 3677, 2876, 1974, 1071, 152, 3696, 2881, 1975, 1062, 129]    # Offset position       xboxCentres =  [642, 648, 654, 652, 656, 1064, 1065, 1070, 1071, 1079, 1851, 1848, 1850, 1854, 1869, 2791, 2779, 2782, 2787, 2811, 3789, 3771, 3769, 3780, 3823]       yboxCentres =  [3700, 2890, 1972, 1054, 120, 3695, 2885, 1973, 1056, 130, 3690, 2884, 1975, 1062, 135, 3685, 2886, 1974, 1061, 132, 3710, 2891, 1975, 1052, 115]    return xboxCentres,yboxCentresdef make_regions(dataArray,x,y,boxSize=60):    # Depending if data header has been previously modified it can have a different array structure. This if statement captures this.    if dataArray.shape[0] == 1:    	dataArray = dataArray[0]    else:        dataArray = dataArray    boxRadius = int(boxSize/2)    # Check if the edges are to close to the image    xRadiusLower = x if x-boxRadius < 0 else boxRadius    xRadiusUpper = 2047-x if x+boxRadius > 2047 else boxRadius    yRadiusLower = y if y-boxRadius < 0 else boxRadius    yRadiusUpper = 2047-y if y+boxRadius > 2047 else boxRadius    holderArray = dataArray[y-boxRadius:y+boxRadius,x-boxRadius:x+boxRadius]    return holderArray@custom_modeldef gaussianTest2(x,y, height=1., center_x=1., center_y=1., width_x=1., width_y=1., theta=0., base=0.0):    width_x = float(width_x)    width_y = float(width_y)        return (height*np.exp(-(((center_x-x)/width_x)**2+((center_y-y)/width_y)**2)/2))+base"""Returns (height, x, y, width_x, width_y): the gaussian parameters of a 2D distribution by calculating its moments"""def moments(data):	total = data.sum()	#print("moments: ",total)	X, Y = np.indices(data.shape)	x = (X*data).sum()/total	y = (Y*data).sum()/total	col = data[:, int(y)]	width_x = np.sqrt(np.abs((np.arange(col.size)-y)**2*col).sum()/col.sum())	row = data[int(x), :]	width_y = np.sqrt(np.abs((np.arange(row.size)-x)**2*row).sum()/row.sum())#	print("moments:",width_x,width_y)	height = data.max()	if math.isnan(width_x):		width_x = 4	if math.isnan(width_y):		width_y = 4    	base = np.median(data)	return height, x, y, width_x, width_y, base"""Returns (height, x, y, width_x, width_y) the gaussian parameters of a 2D distribution found by a fit"""def fitgaussian(data,inputParams=None,weights=None):        # Get input parameters    if inputParams is None:        params = moments(data)    else:        params = inputParams    #print("PAR",params)    # Mathematical model    M = gaussianTest2(*params)        #initiate fitting routines    lmf = LevMarLSQFitter()        # Define blank grid    x,y = np.mgrid[:len(data),:len(data)]        # Fit the function, as defined in M, to the actual data    if weights is None:        fit = lmf(M,x,y,data)    else:        fit = lmf(M,x,y,data,weights=weights)    (height, y, x, width_y, width_x,theta,base) = (fit.height.value,fit.center_x.value,fit.center_y.value,fit.width_x.value,fit.width_y.value,fit.theta.value,fit.base.value)        fwhmx = np.abs(2.0*np.sqrt(2.0*np.log(2.0))*width_x)    fwhmy = np.abs(2.0*np.sqrt(2.0*np.log(2.0))*width_y)    return height, x, y, fwhmx, fwhmy, theta, basedef encircled(arr,rings,cens):    centre = np.sum(arr[int(cens[1])-rings[0]:int(cens[1])+rings[0]+1,int(cens[0])-rings[0]:int(cens[0])+rings[0]+1])    outer  = np.sum(arr[int(cens[1])-rings[1]:int(cens[1])+rings[1]+1,int(cens[0])-rings[1]:int(cens[0])+rings[1]+1])     return(centre/outer)def main():    ''' Main call    python3 focus_finder.py 'filenames_stub*' cameraName darkName outputname    The last "outputname" parameter is optional, and is only looked for if one file has been provided, i.e. a best fit file.         '''     # There are a number of 'options' in the code depending on what it is used for. This section sets some of those parameters.       font = {'family' : 'normal','weight' : 'normal','size'   : 8}    plt.rc('font', **font)    #numFiles = 30  - can force it to do a certain number of files. Generally don't use this.    numFiles = None    plotLog = False             # For the thumbnail images, plot linear or log     saveData = True             # Save the fitted paramaeters or not?    makeSummaryPlot = True      # Plots where the lines are on an image, only works if you supply one image.    damsAllPositive = False     # Reorders input array if the filenames inlcude negative values.    normalise = False           # If neeeded can compare values to the first data point, to look for changes. This just sets first of eveything to zero.        boxSize = 16                # Size of the subbox window          # Get the thumbnail centres    xboxCentres,yboxCentres = boxCentres(sys.argv[2])    # Find some values which are useful for plotting purposes later, but nothing else.    nx = int(np.sqrt(len(xboxCentres)))    originalYboxCentres = copy.deepcopy(yboxCentres)           spotLabels = str(np.arange(len(xboxCentres)))    # Find files based on user stub given in sys.argv[1]    # Note for some files where there a negative DAM positions, we have to change the sequence order to get the files in the correct sequence.    # Simplest way to do this, just to reorder the array - it's crude, but works!!    all_files = glob.glob(sys.argv[1])    if damsAllPositive:        fits_files = sorted(all_files)    else:        temp_files = np.array(sorted(all_files))        # idx = [9,8,7,6,5,4,3,2,1,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]     # dataset: 01.18 full        idx = [9,8,7,6,5,4,3,2,1,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]                               # dataset: 01.18 good        #idx = [24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,25,26,27,28,29]                        # dataset: 01.19        fits_files = temp_files[idx]      print('\nFiles being used:\n',fits_files,'\n --------------------------------- \n \n')    # Current workign directory - needed later.    cwd = os.getcwd()    print('CWD: ',cwd)    # Make blank arrays for later populating    if numFiles is None:        numFiles = len(fits_files)    numSpots = len(xboxCentres)    peak = np.zeros(shape = (numSpots,numFiles))    xpos = np.zeros(shape = (numSpots,numFiles))    ypos = np.zeros(shape = (numSpots,numFiles))    fwhx = np.zeros(shape = (numSpots,numFiles))    fwhy = np.zeros(shape = (numSpots,numFiles))    theta = np.zeros(shape = (numSpots,numFiles))    EE = np.zeros(shape = (numSpots,numFiles))    xValues = np.zeros(numFiles)    averageFWHMx = np.zeros(numFiles)    averageFWHMy = np.zeros(numFiles)    bestFocus = np.zeros(numSpots)    bestFocus = np.zeros(numSpots)    bestPeak = np.zeros(numSpots)    xSpots = np.zeros(numSpots)    ySpots = np.zeros(numSpots)    xnames = np.zeros(numSpots)    ynames = np.zeros(numSpots)        # Try and open the darks, note have to do different things is using the RI detector    try:        darkFrame = fits.open(sys.argv[3])        if sys.argv[2] == 'RI2' or sys.argv[2] == 'HRI2':            darkHeader = darkFrame[1].header        else:            darkHeader = darkFrame[0].header                    if sys.argv[2] == 'RI2' or sys.argv[2] == 'HRI2':            dark = np.array(darkFrame[2].data)        elif sys.argv[2] == 'RI1':            dark = np.array(darkFrame[1].data)        else:            dark = np.array(darkFrame[0].data)    except:        print('No dark frame provided - need to add a relevant element in the command line instructions')        dark = 0        # If making thumbnails, open up the pdf files.    if numFiles == 1:        thumbnailsName = sys.argv[4] + '_thumbnails.pdf'    else:        thumbnailsName = 'thumbnails.pdf'         pp = PdfPages(cwd+'/'+thumbnailsName)               # Start actual analysis. Looping over file after file.     for i in range(numFiles):        flag=0        openFile = fits.open(fits_files[i])        header = openFile[0].header        # Some fiddling has to be done if the data is for the RI detectors        if sys.argv[2] == 'RI2' or sys.argv[2] == 'HRI2':             dataArray = np.array(openFile[2].data)        elif sys.argv[2] == 'RI1':             dataArray = np.array(openFile[1].data)                     else:            dataArray = np.array(openFile[0].data)                # Record possible file ID         fileID = fits_files[i][26:28]            # xValues is the term used for the value in the axis for some of the final plots. This can take the form of dates (as in line below) of focus positions.                        #xValues[i] = float(header['MJD-OBS']) - startMJD        xValues[i] = i            # Subtract the dark and clip negative pixels to zero.                         dataArray = dataArray - dark        dataArray = np.where(dataArray < 1, 1.0, dataArray)                    # Make plot for later use          fig,grid = plt.subplots(nx, nx, figsize=(9,8))        fig.subplots_adjust(top = 0.9, bottom = 0.05, right = 0.95, left = 0.05, hspace=.4, wspace=0.4)        fig.suptitle(fits_files[i], fontsize=12)        # For each of the spots        for s in range(numSpots):            holderArray = dataArray[yboxCentres[s]-boxSize:yboxCentres[s]+boxSize,xboxCentres[s]-boxSize:xboxCentres[s]+boxSize]            # Fit the Gaussian in the box            results = fitgaussian(holderArray)            peak[s,i] = results[0]            xpos[s,i] = results[1] + xboxCentres[s] - boxSize            ypos[s,i] = results[2] + yboxCentres[s] - boxSize            fwhx[s,i] = results[3]            fwhy[s,i] = results[4]            theta[s,i] = results[5]                        ##  Fit encircled energy, based on boxes of size given in "rings"                                rings = [3,7]            EE[s,i] = encircled(holderArray,rings,[np.floor(results[1]),np.floor(results[2])])                                                if i == 1:                 xnames[s] = int(xpos[s,i])                ynames[s] = int(ypos[s,i])            print(i,s,results[3],results[4],EE[s,i])                    # Stupid bit of code to get the plotting windows right!!            if s < nx:                row,col = (nx-1)-s,0            elif s>(nx-1) and s<(nx*2):                row,col = (nx-1)-(s-nx),1            elif s>((nx*2)-1) and s<(nx*3):                row,col = (nx-1)-(s-(2*nx)),2            elif s>((nx*3)-1) and s<(nx*4):                row,col = (nx-1)-(s-(3*nx)),3            elif s>((nx*4)-1) and s<(nx*5):                row,col = (nx-1)-(s-(4*nx)),4            if plotLog:                grid[row,col].imshow(holderArray,interpolation=None,norm=LogNorm(),origin='lower',extent=[0,boxSize*2,0,boxSize*2])            else:                grid[row,col].imshow(holderArray,interpolation=None,origin='lower',extent=[0,boxSize*2,0,boxSize*2])            grid[row,col].set_title(str(int(xpos[s,i])) + ', ' + str(int(ypos[s,i])))                            for r in range(3):                grid[row,col].plot(results[1]+results[3]*(r+1)*np.cos(np.arange(0,7,0.1)),results[2]+results[4]*(r+1)*np.sin(np.arange(0,7,0.1)),c='red',linewidth=0.5)            grid[row,col].set_xlim([0,boxSize*2])            grid[row,col].set_ylim([0,boxSize*2])        print('means:',np.mean(fwhx[:,i]),np.mean(fwhy[:,i]))        print('stds:',np.std(fwhx[:,i]),np.std(fwhy[:,i]))                                                # close the figure to enable making the next page in the pdf        pp.savefig(fig)        plt.close()                # Close the thumbnails file    pp.close()                        originalFWHMx = copy.deepcopy(fwhx)    originalFWHMy = copy.deepcopy(fwhy)    if normalise:        for i in range(numSpots):            fwhx[i,:] = fwhx[i,:]/fwhx[i,0]            fwhy[i,:] = fwhy[i,:]/fwhy[i,0]               normalisePeak = True    if normalisePeak:        for i in range(numSpots):            startPeak = peak[i,0]            peak[i,:] = 100*peak[i,:]/startPeak         # Plot the vairaiton in FWHM for all the different spots. This is good sanity check.    fig,grid = plt.subplots(3, 1, figsize=(7,8))    fig.subplots_adjust(top = 0.95, bottom = 0.1, right = 0.95, left = 0.15, hspace=.2, wspace=0.2)                for i in range(numSpots):        grid[0].scatter(xValues[1:],fwhx[i,1:],label=spotLabels[i])        grid[0].set_title('FWHM x')         grid[0].set_ylabel('Comparative FWHM')         grid[1].scatter(xValues[1:],fwhy[i,1:],label=spotLabels[i])         grid[1].set_title('FWHM y')         grid[1].set_ylabel('FWHM')         grid[1].set_xlabel('Date')         grid[2].scatter(xValues[1:],EE[i,1:],label=spotLabels[i])         grid[2].set_title('EE')         grid[2].set_ylabel('FWHM')         grid[2].set_xlabel('Date')     plt.show()    # Make a figure showing all an image with overlaid thumbnails.    if makeSummaryPlot and numFiles == 1:        plt.imshow(dataArray,interpolation=None,norm=LogNorm(),origin='lower')        boxSize = 30        for s in range(numSpots):            plt.plot([xboxCentres[s]-boxSize,xboxCentres[s]+boxSize,xboxCentres[s]+boxSize,xboxCentres[s]-boxSize,xboxCentres[s]-boxSize],\                     [yboxCentres[s]-boxSize,yboxCentres[s]-boxSize,yboxCentres[s]+boxSize,yboxCentres[s]+boxSize,yboxCentres[s]-boxSize],c='red')        plt.show()    # Saving the objects for later plotting. This saves all the fitted data values, so don't need to repeat the fitting.    if saveData:        # if only 1 file is submitted then you have to give         if numFiles == 1:             print('Only one file has been provided, assuming that this is a best fit plane, need a filename to save the fit parameters.')             outName = sys.argv[4] + '.pkl'        else:            outName = 'sweep.pkl'                    with open(cwd+'/'+outName, 'wb') as f:  # Python 3: open(..., 'wb')            pickle.dump([xValues, fwhx, fwhy, xpos, ypos, spotLabels,  originalFWHMx, originalFWHMy, EE], f)main()